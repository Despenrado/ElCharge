\chapter{Implementacja aplikacji}
%
\section{Model bazy danych}
W systemie wykorzystano dwie nierelacyjne bazy danych: MongoDB i Redis.
MongoDB jest przeznaczona do przechowywania danych aplikacji.
Redis wykorzystuje się tylko do czasowego przechowywania tokenów.

% 
\paragraph{MongoDB\newline}
% TO DO: proszę stosować czcionkę maszynową do kodu źródłowego, nazw zmiennych i klas, nazw plików itp.
% DONE: dziękuję, po prostu nie wiedziałem jak to zrobić z nazwami.
% TO DO: aby zdefiniować zawartość plików json można posłużyć się specyfikacją json schema : https://json-schema.org/
% TO DO: prawdopodobnie dokumenty w MongoDB powstają poprzez mapowanie z obiektów dostępnych w języku programowania,
%  jeśli tak jest, to należy o tym powiedzieć (w opisie implementacji można pokazać diagram klas zawierających odpowiednie pola)
% TO VERIFY: ten json jest wycinkiem z konsoli bazy danych ,,mongo'' po wprowadzeniu odpowiedniego zapytania (,,db.nazwakolekcji.find({});''), różni się od odpowiedzi, które otrzymałem w tej konsoli tym, że sformatowano do czytelnego tekstu, a nie wszystko w jednej linii.
Baza danych składa się z dwóch kolekcji: \texttt{station} i \texttt{user}. Kolekcja \texttt{user} składa się z następujących pól:
\texttt{
    \begin{itemize}
        \item \_id : ObjectId(String)
        \item user\_name : String
        \item email : String
        \item password : String
        \item Model : Object :
        \begin{itemize}
            \item create\_at : ISODate
            \item update\_at : ISODate
            \item delete\_at : ISODate
        \end{itemize}
    \end{itemize}
}

Przykład encji:
\begin{lstlisting}[basicstyle=\tiny\ttfamily]
    {
        "_id":ObjectId("5fb93e4b721953b7c60983c6"),
        "user_name":"newtest",
        "email":"newtest@test.test",
        "password":"$2a$04$o0WfZvdk4WUpsct.BH3zw.3MFJFmUuLe8VjJx2OeyxtZuBliMOrl.",
        "model":{
            "create_at":ISODate("2020-11-21T16:20:27.044Z"),
            "update_at":ISODate("2020-11-21T16:20:27.044Z"),
            "delete_at":ISODate("0001-00-00T00:00:00Z")
        }
    }
\end{lstlisting}

Kolekcja \texttt{station} składa się z następujących pól:
\texttt{
    \begin{itemize}
        \item \_id : String
        \item station\_name : String
        \item owner\_id : String
        \item rating : Double
        \item latitude : Double
        \item longitude : Double
        \item description : String
        \item comments : Array :
        \begin{itemize}
            \item \_id : String
            \item user\_id : String
            \item user\_name : String
            \item text : String
            \item rating : Double
            \item model : Object :
            \begin{itemize}
                \item create\_at : ISODate
                \item update\_at : ISODate
                \item delete\_at : ISODate
            \end{itemize}
        \end{itemize}
        \item model : Object :
        \begin{itemize}
            \item create\_at : ISODate
            \item update\_at : ISODate
            \item delete\_at : ISODate
        \end{itemize}
    \end{itemize}
}

Przykład encji:
\begin{lstlisting}[basicstyle=\tiny\ttfamily]
    {
        "_id":ObjectId("5fca6f81bb37f04ad438c1a5"),
        "station_name":"Station Name",
        "owner_id":"5fb828babe10c57ba70d49cd",
        "rating":3.6666666666666665,
        "description":"description",
        "latitude":57.12662933894774,
        "longitude":14.208925142884254,
        "model":{
            "create_at":ISODate("2020-12-04T17:18:57Z"),
            "update_at":ISODate("2020-12-04T17:20:55Z"),
            "delete_at":ISODate("0001-00-00T00:00:00Z")
        },
        "comments":[
            {
                "_id":"5fca6ff7bb37f04ad438c1a8",
                "user_id":"5fb828babe10c57ba70d49cd",
                "user_name":"test",
                "text":"  Comment 3",
                "rating":5,
                "model":{
                    "create_at":ISODate("2020-12-04T17:20:55Z"),
                    "update_at":ISODate("2020-12-04T17:20:55Z"),
                    "delete_at":ISODate("0001-00-00T00:00:00Z")
                }
            },
            {
                "_id":"5fca6fe5bb37f04ad438c1a7",
                "user_id":"5fb828babe10c57ba70d49cd",
                "user_name":"test",
                "text":" Comment 2",
                "rating":3,
                "model":{
                    "create_at":ISODate("2020-12-04T17:20:37Z"),
                    "update_at":ISODate("2020-12-04T17:20:37Z"),
                    "delete_at":ISODate("0001-00-00T00:00:00Z")
                }
            },
            {
                "_id":"5fca6fb8bb37f04ad438c1a6",
                "user_id":"5fb828babe10c57ba70d49cd",
                "user_name":"test",
                "text":"Comment 1",
                "rating":3,
                "model":{
                    "create_at":ISODate("2020-12-04T17:19:52Z"),
                    "update_at":ISODate("2020-12-04T17:19:52Z"),
                    "delete_at":ISODate("0001-00-00T00:00:00Z")
                }
            }
        ]
    }
\end{lstlisting}

% 
\paragraph{Redis\newline}
Baza danych Redis wykorzystana tylko dla przechowywania tokenów użytkowników, które już wylogowane, ponieważ jedną z wad JWT tokenów jest to, że wygenerowany token nie można zrobić nieważny, dopóki nie skończy się czas jego działania.
Redis częściowo eliminuje ten problem.

W nim przechowuje się para klucz - wartość, pewny czas. Po upływie tego czasu zapis automatycznie jest usuwany.
Dla szybkiego wyszukiwania encja wygląda w następujący sposób: \texttt{token}, \texttt{token}. To pozwala często wylogować użytkowniku, ale zajmuje więcej miejsca niż encja typu: \texttt{user\_id}, \texttt{token}.

\section{Implementacja części serwerowej}
% 
\subsection{Struktura RestApi}
% 
\subsubsection{Narzędzia, technologie, biblioteki}
Do stworzenia serwerowej części aplikacji użyto następujących technologii:
\begin{itemize}
\item Visual Studio Code - środowisko programistyczne;
\item Go - język programowania;
\item Go Modules - system zarządzania zależnościami;
\item gorilla/mux - Router mapuje przychodzące żądania na listę zarejestrowanych tras i wywołuje moduł obsługi tego żądania, który odpowiada URL (ang. \textit{Uniform Resource Locator}) adresowi;
\item sirupsen/logrus - rejestrator strukturalny;
\item mongo-driver - sterowanie MongoDB z języka Go;
\item go-redis/redis - sterowanie Redis z języka Go;
\item dgrijalva/jwt-go - realizacja JWT w języku Go;
\item crypto/bcrypt - realizuje algorytm haszowania bcrypt Provosa i Mazierao;
\item go-ozzo/ozzo-validation - pakiet wspomagający na walidację danych;
\item yaml.v2 - implementuje obsługę YAML (ang. \textit{Yet Another Markup Language});
\item google/uuid - sprawdza i generuje UUID (ang. \textit{universally unique identifier});
\end{itemize}

% 
\subsubsection{Struktura plików RestApi}
Na rysunku \ref{fig:backend_file_structure} została przedstawiona struktura plików części serwerowej. Obok plików, niezbędnych do działania aplikacji, znajdują się pliki pozwalające na prowadzenie testów jednostkowych. Te pliki mają nazwę w postaci \texttt{*\_test.go}.
% TO DO: proszę poukładać obrazki ze strukturami plików obok siebie (pojedynczo zajmują za dużo miejsca)
% TO VERIFY:
\begin{figure}[ht]
\centering
\includegraphics[width=0.25\linewidth]{rys03/backend_file_structure.png}
\caption{Struktura plików}
\label{fig:backend_file_structure}
\end{figure}
\begin{figure}[ht]
	\centering
    \begin{tabular}{@{}rl@{\hspace{3mm}}rl@{\hspace{3mm}}rl@{}}
        a) & \vtop{\vskip-2ex\hbox{\includegraphics[width=0.25\linewidth]{rys03/controllers.png}}} &
        b) & \vtop{\vskip-2ex\hbox{\includegraphics[width=0.25\linewidth]{rys03/model.png}}} &
        c) & \vtop{\vskip-2ex\hbox{\includegraphics[width=0.25\linewidth]{rys03/routers.png}}}
    \end{tabular}
    \caption{Struktura plików: a) kontrolery, b) modeli danych, c) routery.}
    \label{fig:backend_file_structure_1}
\end{figure}
\begin{figure}[ht]
	\centering
    \begin{tabular}{@{}rl@{\hspace{3mm}}rl@{\hspace{3mm}}rl@{}}
        a) & \vtop{\vskip-2ex\hbox{\includegraphics[width=0.25\linewidth]{rys03/services.png}}} &
        b) & \vtop{\vskip-2ex\hbox{\includegraphics[width=0.25\linewidth]{rys03/storage.png}}} &
        c) & \vtop{\vskip-2ex\hbox{\includegraphics[width=0.25\linewidth]{rys03/utils.png}}}
    \end{tabular}
    \caption{Struktura plików: a) serwisy, b) wszpółdziałania z bazą danych, c) narzędzia.}
    \label{fig:backend_file_structure_2}
\end{figure}

Katalog \texttt{config} zawiera pliki konfiguracyjne. W katalogu \texttt{controllers} (rys.~\ref{fig:backend_file_structure_1}a) znajdują się kontrolery, które są wykorzystywanie do połączenia poziomu serwisów z punktami końcowymi serwera (ang.~\emph{endpoints}).

Do katalogu \texttt{deploy} jest kompilowana aplikacja przy uruchomieniu \texttt{Makefile}.

Katalog \texttt{models}(rys. \ref{fig:backend_file_structure_1}b) zawiera modeli danych do przechowywania w bazie danych oraz do przekazania do interfejsu użytkownika.

Katalog \texttt{routers} (rys. \ref{fig:backend_file_structure_1}c) zawiera plik, w którym zachodzi mapowanie punktów końcowych z kontrolerami.

Funkcje lub metody przechowywane w katalogu \texttt{services} (rys. \ref{fig:backend_file_structure_2}a) prowadzą obróbkę danych i podejmują decyzję co z nimi trzeba zrobić.

Współpraca z bazą danych zachdzi w katalogu \texttt{storage} (rys. \ref{fig:backend_file_structure_2}b). Katalog \texttt{mongostore} wspódziałuje z MongoDB, notomiast \texttt{teststore} wykorzystuje się do testowania, które będzie omówione w odpowiednim rozdiale \ref{ch:Testy}.

W katalogu \texttt{utils} (rys. \ref{fig:backend_file_structure_2}c) znajdują się rzeczy wspomagające, naprykład lista błedów lub rejestracja działania serwera.


\subsubsection{KOnfiguracja serwera}
Do zapobiegania ponowniej kompilacji w przypadku zmiany portu, na którym działa serwer lub adresów baz danych, została utworzona struktura \texttt{Config} \ref{list:config_restapi} (plikutils/config.go), która przy uruchomienui aplikacji pobiera dane z pliku, który zostanie podany jako parametr wejściowy.
Plik musi być typu \texttt{yaml}. Za pomocą biblioteki \texttt{yaml.v2} ten plik jest parsowany do obiektu struktury \texttt{Config} \ref{list:config_restapi_new}. Przykład pliku:
\begin{lstlisting}[basicstyle=\tiny\ttfamily]
    bind_addr: :8081
    database_url: mongodb://127.0.0.1:27017
    db_name: elCharge
    db_user_collection: user
    db_station_collection: station
    db_redis: 127.0.0.1:6379
    jwtKey: 21d5680b6a
\end{lstlisting}

\begin{lstlisting}[label=list:config_restapi,caption=Klasa konfiguracyjna części serwerowej,basicstyle=\tiny\ttfamily]
    type Config struct {
        BindAddr            string `yaml:"bind_addr"`
        DatabaseURL         string `yaml:"database_url"`
        DbName              string `yaml:"db_name"`
        DbUserCollection    string `yaml:"db_user_collection"`
        DbStationCollection string `yaml:"db_station_collection"`
        RedisDB             string `yaml:"db_redis"`
        JWTKey              string `yaml:"jwtKey"`
    }
\end{lstlisting}

\begin{lstlisting}[label=list:config_restapi_new,caption=Wczytanie pliku konfiguracyjnego części serwerowej,basicstyle=\tiny\ttfamily]
    func NewConfig(path string) (*Config, error) {
        configFile, err := ioutil.ReadFile(path)
        if err != nil {
            return nil, err
        }
        config := &Config{}
        err = yaml.Unmarshal(configFile, config)
        if err != nil {
            return nil, err
        }
        return config, nil
    }
\end{lstlisting}
% 
\subsubsection{Przepływ danych}
Na rysunku \ref{fig:backend_data_flow} został przedstawiony schemat przetwarzania i przepływu danych przy wysyłaniu zapytania do części serwerowej niniejszej aplikacji.
% TO DO: rysunek do przerysowania (proszę zacieśnić bloczki, wtedy przy skalowaniu do szerokości strony czcionka stanie się większa
% DONE:
\begin{figure}[ht]
\centering
\includegraphics[width=1\linewidth]{rys03/backend_data_flow.png}
\caption{Przepływ danych}
\label{fig:backend_data_flow}
\end{figure}

% 
\subsubsection{Punkty końcowe}
Część serwerowa jest napisana zgodnie z modelem Rest API. Wymiana danymi zachodzi za pomocą standardów: HTTP (ang. \textit{HyperText Transfer Protocol}), URL, JSON.
W tabeli \ref{tab:endpoints} przedstawiony spis endpointów razem z metodą ich wysłania oraz krótkim opisem.
\begin{table}[htb] \small
    \caption{Lista Enpointów części serwerowej}
    \label{tab:endpoints}
    \begin{tabularx}{\linewidth}{| m{0.45cm} | m{1.5cm} | m{6cm} | X |}
    \hline
    № & Metoda & Endpoint & Opis \\
    \hline
    1 & GET & /api/v1 & Endpoint do testowania działania serwera. \\
    \hline
    2 & POST & /api/v1/login & Zalogowanie się użytkownika. \\
    \hline
    3 & GET & /api/v1/logout & Wylogowanie się użytkownika. \\
    \hline
    4 & POST & /api/v1/users & Tworzenie użytkownika / rejestracja \\
    \hline
    5 & GET & /api/v1/users/{id} & Wczytywanie danych jednego użytkownika. \\
    \hline
    6 & PUT & /api/v1/users/{id} & Edycja użytkownika. \\
    \hline
    7 & DELETE & /api/v1/users/{id} & Usuwanie użytkownika. \\
    \hline
    8 & GET & /api/v1/users/read?skip=""\&limit="" & Wczytywanie danych limitowanej listy użytkowników użytkownika. \\
    \hline
    9 & POST & /api/v1/stations & Tworzenie stacji ładowniczej. \\
    \hline
    10 & GET & /api/v1/stations/{id} & Wczytywanie danych jednej stacji ładowniczej. \\
    \hline
    11 & PUT & /api/v1/stations/{id}?ownid="" & Edycja stacji. \\
    \hline
    12 & DELETE & /api/v1/stations/{id} & Usuwanie stacji ładowniczej. \\
    \hline
    13 & GET & /api/v1/stations/read?skip=""\&limit=""\&lat=""\&lng=""\&dist=""\&descr=""\&nam="" & Wyszukiwnaie stacji ładowniczej w zależności od parametrów. \\
    \hline
    14 & POST & /api/v1/stations/{sid}/comments & Tworzenie komentarza. \\
    \hline
    15 & GET & /api/v1/stations/{sid}/comments{id} & Wczytywanie danych jednego komentarza. \\
    \hline
    16 & PUT & /api/v1/stations/{sid}/comments{id} & Edycja komentarza. \\
    \hline
    17 & DELETE & /api/v1/stations/{sid}/comments{id} & Usuwanie komentarza. \\
    \hline
    18 & GET & /api/v1/stations/{sid}/read?skip=""\&limit="" & Wczytywanie danych limitowanej listy komentarzy należących do pewnej stacji. \\
    \hline
    \end{tabularx}
\end{table}

Kodem \ref{list:routers} została przedstawiona implementacja endpointów.
Dla rejestracji połączeń wchodzących zostanły użyte metody medialne \texttt{s.logger.SetRequestID} do przyznaczenia id każdemu połączniu oraz \texttt{s.logger.LogRequest} do wypisywania tego do konsoli.
Dla większości przypadków też jest sprawdzano czy jest użytkownik zalogowany do systemu \texttt{s.authController.CheckToken}. To będzie wyjaśnione później (sekcja \ref{sec:autentykacja}).
\begin{lstlisting}[label=list:routers,caption=Implementacja punktów końcowych,basicstyle=\tiny\ttfamily]
func (s *Server) SetupRouters() *mux.Router {
	v1 := "/api/v1"
	s.router.Schemes("http")
	s.router.Use(s.logger.SetRequestID) // middleware
	s.router.Use(s.logger.LogRequest)   // middleware
	s.router.HandleFunc(v1, s.testController.TestAPIV1()).Methods("GET")
	s.router.HandleFunc(v1+"/users", s.authController.CreateUser()).Methods("POST")
	s.router.HandleFunc(v1+"/login", s.authController.Login()).Methods("POST")
	s.router.HandleFunc(v1+"/logout/{id}", s.authController.Logout()).Methods("GET")

	user := s.router.PathPrefix(v1 + "/users").Subrouter()
	user.Use(s.authController.CheckToken)
	user.HandleFunc("/read", s.userController.Read()).Methods("GET")
	user.HandleFunc("/{id}", s.userController.FindByID()).Methods("GET")
	user.HandleFunc("/{id}", s.userController.DeleteByID()).Methods("DELETE")
	user.HandleFunc("/{id}", s.userController.UpdateByID()).Methods("PUT")

	stat := s.router.PathPrefix(v1 + "/stations").Subrouter()
	stat.Use(s.authController.CheckToken)
	stat.HandleFunc("", s.statController.CreateStation()).Methods("POST")
	stat.HandleFunc("/read", s.statController.Read()).Methods("GET")
	stat.HandleFunc("/{id}", s.statController.FindByID()).Methods("GET")
	stat.HandleFunc("/{id}", s.statController.DeleteByID()).Methods("DELETE")
	stat.HandleFunc("/{id}", s.statController.UpdateByID()).Methods("PUT")

	comm := stat.PathPrefix("/{sid}/comments").Subrouter()
	comm.Use(s.authController.CheckToken)
	comm.HandleFunc("/read", s.commController.Read()).Methods("GET")
	comm.HandleFunc("", s.commController.CreateComment()).Methods("POST")
	comm.HandleFunc("/{id}", s.commController.FindByID()).Methods("GET")
	comm.HandleFunc("/{id}", s.commController.DeleteByID()).Methods("DELETE")
	comm.HandleFunc("/{id}", s.commController.UpdateByID()).Methods("PUT")
	return s.router
}
\end{lstlisting}

% 
\subsection{Funkcje części serwerowej}
W tej sekcji są opisane implementacje endpointów części serwerowej.
% 
\subsubsection{Użytkownik}
Użytkownik jest niezbędny w pierwszej kolejności do uwierzytelniania. Niektóre dane użytkownika też są używane dla rozumienia: do kogo należy stacja ładownicza lub komentarz.

W listingu \ref{list:user_model} jest przedstawiona struktura użytkownika, wraz ze sposobem konwersji do JSON i BSON, która znajdująca się w pliku \texttt{models/user}.
\begin{lstlisting}[label=list:user_model,caption=Model danych użytkownika,basicstyle=\tiny\ttfamily]
    type User struct {
        ID       string `bson:"_id,omitempty" json:"_id,omitempty"`
        UserName string `bson:"user_name,omitempty" json:"user_name,omitempty"`
        Email    string `bson:"email,omitempty" json:"email,omitempty"`
        Password string `bson:"password,omitempty" json:"password,omitempty"`
        Model
    }
\end{lstlisting}

% 
% \paragraph{Dodawanie}\mbox{}\\
% Do tworzenia użytkownika został zaimplementowany endpoint \texttt{/api/v1/users}.
% Metoda zapytania \texttt{POST}.
% Jako ciało zapytania należy wysyłać obiekt w formacie JSON. Przykład:
% \begin{lstlisting}[basicstyle=\tiny\ttfamily]
%     {
%         "email": "email@test3.com",
%         "user_name": "test_user_1",
%         "password": "password"
%     }
% \end{lstlisting}
% Na serwerze nie sprawdza się, czy jest użytkownik już zalogowany, ponieważ ten endpoint również używany przy rejestracji.
% Zwraca JSON obiekt stworzonego użytkownika.

% Za pomocą routera jest realizowane przekierowanie z URL do wywołania metody kontrolera \texttt{CreateUser()} (listing \ref{list:user_controller_create}), w którym zaczyna się obróbka biznesowa zapytania.
% W tej metodzie są dekodowane dane z ciała zapytania, które są w formacie JSON, i przekazane do metody serwisu \texttt{CreateUser()} (listing \ref{list:user_service_create}). Po otrzymaniu danych z serwisu jest wysyłana odpowiedź.
% \begin{lstlisting}[label=list:user_controller_create,caption=Kontroler tworzenia użytkownika,basicstyle=\tiny\ttfamily]
%     func (c *UserController) CreateUser() http.HandlerFunc {
%         return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
%             u := &models.User{}
%             err := json.NewDecoder(r.Body).Decode(u)
%             if err != nil {
%                 utils.Error(w, r, http.StatusBadRequest, err)
%                 return
%             }
%             u, err = c.service.User().CreateUser(u)
%             if err != nil {
%                 utils.Error(w, r, http.StatusBadRequest, err)
%                 return
%             }
%             utils.Respond(w, r, http.StatusCreated, u)
%         })
%     }
% \end{lstlisting}

% W metodzie \texttt{CreateUser()} (listing \ref{list:user_service_create}) zachodzi:
% \begin{itemize}
%     \item walidacja danych;
%     \item sprawdzanie, czy istnieje użytkownik z taką pocztą mailową;
%     \item jeśli nie istnieje, to zachodzi szyfrowanie hasła oraz ustalenie czasu tworzenia i edycji obiektu. Jeśli już istnieje, to zwraca błąd;
%     \item tworzenie nowego użytkownika w bazie danych;
%     \item przygotowanie obiektu użytkownika do transmisji: usuwanie hasła i daty tworzenia dla bezpieczeństwa oraz szybkości transmisji danych.
% \end{itemize}
% Ta metoda znajduje się w pliku \texttt{services/v1/userservice.go}.
% \begin{lstlisting}[label=list:user_service_create,caption=Serwis tworzenia użytkownika,basicstyle=\tiny\ttfamily]
%     func (s *UserService) CreateUser(u *models.User) (*models.User, error) {
%         if err := u.Validate(); err != nil {
%             return u, err
%         }
%         _, err := s.storage.User().FindByEmail(u.Email)
%         if err != utils.ErrRecordNotFound {
%             if err != nil {
%                 return nil, err
%             }
%             return u, utils.ErrRecordAlreadyExists
%         }
%         if err := u.BeforeCreate(); err != nil {
%             return u, err
%         }
%         id, err := s.storage.User().Create(u)
%         if err != nil {
%             return nil, err
%         }
%         u, err = s.storage.User().FindByID(id)
%         if err != nil {
%             return nil, err
%         }
%         u.Sanitize()
%         return u, nil
%     }
% \end{lstlisting}

% Metoda \texttt{Create()} (listing \ref{list:user_repository_create}) tworzy zapis nowego użytkownika w bazie danych i zwraca jego ID.
% Ona znajduję się w \texttt{/storage/mongostore/userrepository.go}.
% \begin{lstlisting}[label=list:user_repository_create,caption=Zachowanie użytkownika do bazy danych,basicstyle=\tiny\ttfamily]
%     func (r *UserRepository) Create(u *models.User) (string, error) {
%         res, err := r.col.InsertOne(context.TODO(), u)
%         if err != nil {
%             return "", err
%         }
%         id := res.InsertedID.(primitive.ObjectID).Hex()
%         return id, nil
%     }
% \end{lstlisting}

% 
\paragraph{Wczytywanie}\mbox{}\\

Do wczytywania konkretnego użytkownika został zaimplementowany endpoint \texttt{/api/v1/users/{id}}.
Metoda zapytania \texttt{GET}.
W adresie URL musi być podany id użytkownika.
Dla korzystania z danego endpointu użytkownik musi być zalogowany.
Zwraca JSON obiekt znalezionego użytkownika.

Za pomocą routera jest realizowane przekierowanie z URL do wywołania metody kontrolera użytkownika \texttt{FindByID()} (listing \ref{list:user_controller_findbyid}), która zaczyna obróbkę biznesową zapytania.
W tej metodzie jest wywoływana metoda serwisu \texttt{FindByID()} (listing \ref{list:user_service_findbyid}). Później jest wysyłana odpowiedź.
\begin{lstlisting}[label=list:user_controller_findbyid,caption=Kontroler wczytywania użytkownika,basicstyle=\tiny\ttfamily]
    func (c *UserController) FindByID() http.HandlerFunc {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            params := mux.Vars(r)
            id, ok := params["id"]
            if !ok {
                utils.Error(w, r, http.StatusBadRequest, utils.ErrWrongRequest)
                return
            }
            u, err := c.service.User().FindByID(id)
            if err != nil {
                utils.Error(w, r, http.StatusNoContent, err)
                return
            }
            utils.Respond(w, r, http.StatusFound, u)
        })
    }
\end{lstlisting}
% 
Metoda \texttt{FindByID()} (listing \ref{list:user_service_findbyid}) z pliku \texttt{services/v1/userservice.go}:
\begin{lstlisting}[label=list:user_service_findbyid,caption=Serwis wczytywania użytkownika,basicstyle=\tiny\ttfamily]
    func (s *UserService) FindByID(id string) (*models.User, error) {
        u, err := s.storage.User().FindByID(id)
        if err != nil {
            return nil, err
        }
        u.Sanitize()
        return u, nil
    }
\end{lstlisting}
% 
Metoda \texttt{FindByID()} (listing \ref{list:user_repository_findbyid}) wyszukuje użytkownika z pewnym ID w bazie dabych.
Ona znajduję się w \texttt{/storage/mongostore/userrepository.go}.
\begin{lstlisting}[label=list:user_repository_findbyid,caption=Wczytywanie uzytkownika z bazy danych,basicstyle=\tiny\ttfamily]
    func (r *UserRepository) FindByID(id string) (*models.User, error) {
        idi, err := primitive.ObjectIDFromHex(id)
        if err != nil {
            return nil, err
        }
        filter := bson.M{"_id": idi}
        res := r.col.FindOne(context.TODO(), filter)
        u := &models.User{}
        err = res.Decode(u)
        if err != nil {
            return nil, utils.ErrRecordNotFound
        }
        return u, nil
    }
\end{lstlisting}

% 
\paragraph{Edycja}\mbox{}\\

Do edycji użytkownika został zaimplementowany endpoint \texttt{/api/v1/users/{id}}.
Metoda zapytania \texttt{PUT}.
W adresie URL musi być podany id użytkownika.
Jako ciało zapytania należy wysyłać obiekt w formacie JSON. Przykład:
\begin{lstlisting}[basicstyle=\tiny\ttfamily]

    {
        "user_name": "test_user_2",
        "update_at": "2020-11-01T13:27:31.105Z"
    }
\end{lstlisting}
Dla korzystania z danego endpointu użytkownik musi być zalogowany.

Za pomocą routera jest realizowane przekierowanie z URL do wywołania metody kontrolera użytkownika \texttt{UpdateByID()} (listing \ref{list:user_controller_UpdateByID}), która zaczyna obróbkę biznesową zapytania.
W tej metodzie jest wywoływana metoda serwisu \texttt{UpdateByID()} (listing \ref{list:user_service_UpdateByID}). Później jest wysyłana odpowiedź.
\begin{lstlisting}[label=list:user_controller_UpdateByID,caption=Kontroler edycji użytkownika,basicstyle=\tiny\ttfamily]
    func (c *UserController) UpdateByID() http.HandlerFunc {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            params := mux.Vars(r)
            id, ok := params["id"]
            if !ok {
                utils.Error(w, r, http.StatusNoContent, utils.ErrWrongRequest)
                return
            }
            u := &models.User{}
            err := json.NewDecoder(r.Body).Decode(u)
            if err != nil {
                utils.Error(w, r, http.StatusBadRequest, err)
                return
            }
            u, err = c.service.User().UpdateByID(id, u)
            if err != nil {
                utils.Error(w, r, http.StatusNotFound, err)
                return
            }
            utils.Respond(w, r, http.StatusOK, u)
        })
    }
\end{lstlisting}
% % 
Metoda \texttt{UpdateByID()} (listing \ref{list:user_service_UpdateByID}) z pliku \texttt{services/v1/userservice.go}:
\begin{lstlisting}[label=list:user_service_UpdateByID,caption=Serwis edycji użytkownika,basicstyle=\tiny\ttfamily]
    func (s *UserService) UpdateByID(id string, u *models.User) (*models.User, error) {
        if u.Password != "" {
            tmp, err := models.EncryptString(u.Password)
            u.Password = tmp
            if err != nil {
                return nil, err
            }
        }
        err := s.storage.User().UpdateByID(id, u)
        if err != nil {
            return nil, err
        }
        u, err = s.storage.User().FindByID(id)
        if err != nil {
            return nil, err
        }
        u.Sanitize()
        return u, nil
    }
\end{lstlisting}
% % 
Metoda \texttt{UpdateByID()} (listing \ref{list:user_repository_UpdateByID}) wyszukuje i aktualizuje użytkownika z pewnym ID i \texttt{update\_at} w bazie dabych.
Ona znajduję się w \texttt{/storage/mongostore/userrepository.go}.
\begin{lstlisting}[label=list:user_repository_UpdateByID,caption=Edycja uzytkownika w bazie danych,basicstyle=\tiny\ttfamily]
    func (r *UserRepository) UpdateByID(id string, u *models.User) error {
        idi, err := primitive.ObjectIDFromHex(id)
        if err != nil {
            return err
        }
        filter := bson.M{
            "_id":             idi,
            "model.update_at": u.UpdateAt,
        }
        update := bson.M{
            "model.update_at": models.GetTimeNow(),
        }
        if u.UserName != "" {
            update["user_name"] = u.UserName
        }
        if u.Email != "" {
            update["email"] = u.Email
        }
        if u.Password != "" {
            update["password"] = u.Password
        }
        _, err = r.col.UpdateOne(context.TODO(), filter, bson.M{
            "$set": update})
        if err != nil {
            return err
        }
        return nil
    }
\end{lstlisting}

% % 
\paragraph{Usunięcie}\mbox{}\\

Do Usunięcia użytkownika został zaimplementowany endpoint \texttt{/api/v1/users/{id}}.
Metoda zapytania \texttt{DELETE}.
W adresie URL musi być podany id użytkownika.

Dla korzystania z danego endpointu użytkownik musi być zalogowany.

Za pomocą routera jest realizowane przekierowanie z URL do wywołania metody kontrolera użytkownika \texttt{DeleteByID()} (listing \ref{list:user_controller_DeleteByID}), która zaczyna obróbkę biznesową zapytania.
W tej metodzie jest wywoływana metoda serwisu \texttt{DeleteByID()} (listing \ref{list:user_service_DeleteByID}). Później jest wysyłana odpowiedź.
\begin{lstlisting}[label=list:user_controller_DeleteByID,caption=Kontroler usunięcia użytkownika,basicstyle=\tiny\ttfamily]
    func (c *UserController) DeleteByID() http.HandlerFunc {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            params := mux.Vars(r)
            id, ok := params["id"]
            if !ok {
                utils.Error(w, r, http.StatusBadRequest, utils.ErrWrongRequest)
                return
            }
            err := c.service.User().DeleteByID(id)
            if err != nil {
                utils.Error(w, r, http.StatusNoContent, err)
                return
            }
            utils.Respond(w, r, http.StatusOK, nil)
        })
    }
\end{lstlisting}
% % 
Metoda \texttt{DeleteByID()} (listing \ref{list:user_service_DeleteByID}) z pliku \texttt{services/v1/userservice.go}:
\begin{lstlisting}[label=list:user_service_DeleteByID,caption=Serwis usunięcia użytkownika,basicstyle=\tiny\ttfamily]
    func (s *UserService) DeleteByID(id string) error {
        return s.storage.User().DeleteByID(id)
    }
\end{lstlisting}
% 
Metoda \texttt{DeleteByID()} (listing \ref{list:user_repository_DeleteByID}) usuwa użytkownika z pewnym ID z bazy dabych.
Ona znajduję się w \texttt{/storage/mongostore/userrepository.go}.
\begin{lstlisting}[label=list:user_repository_DeleteByID,caption=Usunięcie uzytkownika z bazy danych,basicstyle=\tiny\ttfamily]
    func (r *UserRepository) DeleteByID(id string) error {
        idi, err := primitive.ObjectIDFromHex(id)
        if err != nil {
            return err
        }
        filter := bson.M{"_id": idi}
        res, err := r.col.DeleteOne(context.TODO(), filter)
        if err != nil {
            return err
        }
        if res.DeletedCount == 0 {
            return utils.ErrRecordNotFound
        }
        return nil
    }
\end{lstlisting}

\subsubsection{Autentykacja / Logowanie i rejestracja}
\label{sec:autentykacja}
Dla autentykacji został wykorzystany JWT token, który jest generowany na serwerze, przy znalezieniu użytkownika o podanym adresie mailowym i haśle w bazie danych, i za tym jest wysłany w nagłówku odpowiedzi razem z danymi tego użytkownika.
Ten token jest ważny jeden tydzień, za tym traci ważność i należy zalogować się ponownie. Wewnątrz tokena znajduje się nagłówek, sygnatura, czas ważności i id użytkownika.
Większość endpointów dostępny tylko dla uwierzytelnionych użytkowników. W nagłówku zapytania musi znajdować się ważny token oraz ten token nie musi znajdować się na czarnej liście tokenów przechowywanych w bazie danych Redis.

\paragraph{Logowanie\newline}
Dla zalogowania należy wysłać metodą POST zapytanie na endpoint \texttt{api/v1/login} z ciałem zawierającym \texttt{email} i \texttt{password} w formacie JSON:
\begin{lstlisting}[basicstyle=\tiny\ttfamily]
    {
        "email": "test@test.test",
        "password": "password"
    }
\end{lstlisting}

Mapowanie routera przekieruje to zapytanie do metody \texttt{Login()}, która się znajduje w \texttt{controllers/api/authcontroller.go} \ref{list:authcontroller_login}.
W tej metodzie, po znalezieniu użytkownika o takim adresie mailowym i hasle (\ref{list:authcontroller_login}), jest generowany token JWT (\ref{list:get_jwt_token}) i wysyła się odpowidż zawierająca nagłówek z tokenem oraz ciało z danymi użytkownika.
\begin{lstlisting}[label=list:authcontroller_login,caption=Kontroller logowania użytkownika,basicstyle=\tiny\ttfamily]
    func (c *AuthController) Login() http.HandlerFunc {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            u := &models.User{}
            err := json.NewDecoder(r.Body).Decode(u)
            if err != nil {
                utils.Error(w, r, http.StatusBadRequest, err)
                return
            }
            u, err = c.service.User().Login(u)
            if err != nil {
                utils.Error(w, r, http.StatusUnauthorized, utils.ErrIncorrectEmailOrPassword)
                return
            }
            token, err := c.createTokenString(u.ID)
            if err != nil {
                utils.Error(w, r, http.StatusInternalServerError, err)
                return
            }
            w.Header().Set("Authorization", "Bearer "+token)
            utils.Respond(w, r, http.StatusOK, u)
        })
    }
\end{lstlisting}

\begin{lstlisting}[label=list:get_jwt_token,caption=Generacja JWT tokena,basicstyle=\tiny\ttfamily]
    func (c *AuthController) createTokenString(uid string) (string, error) {
        expirationTime := time.Now().Add(168 * time.Hour)
        claims := &Claims{
            UID: uid, // user id
            StandardClaims: jwt.StandardClaims{
                ExpiresAt: expirationTime.Unix(), //lifetime
            },
        }
        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
        tokenString, err := token.SignedString([]byte(c.jwtKey))
        if err != nil {
            return "", err
        }
        return tokenString, nil
    }
\end{lstlisting}

Dla wyszukiwania użytkownika o podanym adresie mailowym i haśle jest używana metoda \texttt{Login} (\ref{list:userservice_login}) znajdująca się w \texttt{serwices/api/v1/userservice.go},
która wyszukuje w bazie danych użytkownika o podanym adresie (adresy mailowe są unikalne) za pomocą metody \texttt{FindByEmal()} (\ref{list:userrepository_findbyemail}) z pliku \texttt{storage/mongostore/userrepository.go} i porównuje hashowane hasło, z bazy danych, z nie haszowanym, z zapytania (\ref{list:validate_password}).
\begin{lstlisting}[label=list:userservice_login,caption=Serwis logowania uzytkownika,basicstyle=\tiny\ttfamily]
    func (s *UserService) Login(u *models.User) (*models.User, error) {
        if err := u.Validate(); err != nil {
            return nil, err
        }
        u2, err := s.storage.User().FindByEmail(u.Email)
        if err != nil {
            return nil, err
        }
        if !u2.VerifyPassword(u.Password) {
            return nil, utils.ErrIncorrectEmailOrPassword
        }
        u2.Sanitize()
        return u2, nil
    }
\end{lstlisting}

\begin{lstlisting}[label=list:userrepository_findbyemail,caption=Wysukiwanie użytkownika w bazie po adresie mailowym,basicstyle=\tiny\ttfamily]
    func (r *UserRepository) FindByEmail(email string) (*models.User, error) {
        filter := bson.M{"email": email}
        res := r.col.FindOne(context.TODO(), filter)
        u := &models.User{}
        err := res.Decode(u)
        if err != nil {
            return nil, utils.ErrRecordNotFound
        }
        return u, nil
    }
\end{lstlisting}

\begin{lstlisting}[label=list:validate_password,caption=Porównywanie hasła,basicstyle=\tiny\ttfamily]
    func (u *User) VerifyPassword(p string) bool {
        return bcrypt.CompareHashAndPassword([]byte(u.Password), []byte(p)) == nil
    }
\end{lstlisting}

\paragraph{Rejestracja\newline}
Aby zarejestrować nowego użytkownika, należy wysłać zapytanie POST na adres \texttt{api/v1/users} z odpowiednim ciałem JSON:
\begin{lstlisting}[basicstyle=\tiny\ttfamily]
    {
        "email": "email@test3.com",
        "user_name": "test_user_1",
        "password": "password"
    }
\end{lstlisting}

Dalej zostanie wykonana metoda \texttt{CreateUser()} z pliku \texttt{controllers/api/v1/authcontroller.go} \ref{list:user_controller_create}.
W tej metodzie są dekodowane dane z ciała zapytania, które są w formacie JSON, i przekazane do metody \texttt{CreateUser()} (listing \ref{list:user_service_create}), która znajduje się w pliku \texttt{services/api/v1/userservice.go}. Po otrzymaniu danych z serwisu jest tworzony token oraz wysyłana odpowiedź, która zawiera wygenerowany token i dane utworzonego użytkownika.
\begin{lstlisting}[label=list:user_controller_create,caption=Kontroler tworzenia użytkownika,basicstyle=\tiny\ttfamily]
    func (c *UserController) CreateUser() http.HandlerFunc {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            u := &models.User{}
            err := json.NewDecoder(r.Body).Decode(u)
            if err != nil {
                utils.Error(w, r, http.StatusBadRequest, err)
                return
            }
            u, err = c.service.User().CreateUser(u)
            if err != nil {
                utils.Error(w, r, http.StatusBadRequest, err)
                return
            }
            utils.Respond(w, r, http.StatusCreated, u)
        })
    }
\end{lstlisting}

W metodzie \texttt{CreateUser()} (listing \ref{list:user_service_create}) zachodzi:
\begin{itemize}
    \item walidacja danych;
    \item sprawdzanie, czy istnieje użytkownik z taką pocztą mailową;
    \item jeśli nie istnieje, to zachodzi haszowanie hasła \ref{list:hash_pass} oraz ustalenie czasu tworzenia i edycji obiektu. Jeśli już istnieje, to zwraca błąd;
    \item tworzenie nowego użytkownika w bazie danych;
    \item przygotowanie obiektu użytkownika do transmisji: usuwanie hasła i daty tworzenia dla bezpieczeństwa oraz szybkości transmisji danych.
\end{itemize}
Ta metoda znajduje się w pliku \texttt{services/api/v1/userservice.go}.
\begin{lstlisting}[label=list:user_service_create,caption=Serwis tworzenia użytkownika,basicstyle=\tiny\ttfamily]
    func (s *UserService) CreateUser(u *models.User) (*models.User, error) {
        if err := u.Validate(); err != nil {
            return u, err
        }
        _, err := s.storage.User().FindByEmail(u.Email)
        if err != utils.ErrRecordNotFound {
            if err != nil {
                return nil, err
            }
            return u, utils.ErrRecordAlreadyExists
        }
        if err := u.BeforeCreate(); err != nil {
            return u, err
        }
        id, err := s.storage.User().Create(u)
        if err != nil {
            return nil, err
        }
        u, err = s.storage.User().FindByID(id)
        if err != nil {
            return nil, err
        }
        u.Sanitize()
        return u, nil
    }
\end{lstlisting}
\begin{lstlisting}[label=list:hash_pass,caption=Haszowanie hasła,basicstyle=\tiny\ttfamily]
    func EncryptString(str string) (string, error) {
        b, err := bcrypt.GenerateFromPassword([]byte(str), bcrypt.MinCost)
        if err != nil {
            return "", err
        }
        return string(b), nil
    }
\end{lstlisting}

Metoda \texttt{Create()} (listing \ref{list:user_repository_create}) tworzy zapis nowego użytkownika w bazie danych i zwraca jego ID.
Ona znajduję się w \texttt{/storage/mongostore/userrepository.go}.
\begin{lstlisting}[label=list:user_repository_create,caption=Zachowanie użytkownika do bazy danych,basicstyle=\tiny\ttfamily]
    func (r *UserRepository) Create(u *models.User) (string, error) {
        res, err := r.col.InsertOne(context.TODO(), u)
        if err != nil {
            return "", err
        }
        id := res.InsertedID.(primitive.ObjectID).Hex()
        return id, nil
    }
\end{lstlisting}

\paragraph{Sprawdzenie tokenu\newline}
Większość, jak juz zostało powiedziano, endpointów pracują tylko z uwierzytelnionymi użytkownikami. Dla realizacji tej funkcji należy sprawdzić token, który zawiera nagłówek zapytania.
Token musi nie tylko nie stracić ważności, ale i nie znajdować się w czarnej liście tokenów, która znajduje się Redis, bazie danych wykonującej rolę pamięci podręcznej.
Metoda \texttt{CheckToken()} sprawdza te rzeczy (\ref{list:CheckToken}).
\begin{lstlisting}[label=list:CheckToken,caption=Walidacja JWT tokenu,basicstyle=\tiny\ttfamily]
    func (c *AuthController) CheckToken(next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            tokenString := r.Header.Get("Authorization")
            if len(tokenString) == 0 {
                utils.Error(w, r, http.StatusUnauthorized, errors.New("Missing Authorization Header"))
                return
            }
            tokenString = strings.Replace(tokenString, "Bearer ", "", 1)
            claims := &Claims{}
            tkn, err := jwt.ParseWithClaims(tokenString, claims, func(token *jwt.Token) (interface{}, error) {
                return []byte(c.jwtKey), nil
            })
            if err != nil {
                if err == jwt.ErrSignatureInvalid {
                    utils.Error(w, r, http.StatusUnauthorized, err)
                    return
                }
                utils.Error(w, r, http.StatusBadRequest, err)
                return
            }
            if !tkn.Valid {
                utils.Error(w, r, http.StatusUnauthorized, err)
                return
            }
            _, err = c.rClient.Get(tokenString[37:]).Result() // find tocken in Redis
            if err != redis.Nil {
                utils.Error(w, r, http.StatusUnauthorized, errors.New("Invalid token"))
                return
            }
            next.ServeHTTP(w, r)
        })
    }
\end{lstlisting}

\paragraph{Wylogowanie\newline}
Po wysłaniu zapytania GET na adres \texttt{api/v1/logout}, zostanie wywoływana metoda \texttt{Logout()} (\ref{list:logout}) podczas działania której zostanie sprawdzony token (\ref{list:CheckToken}), za tym dodany do bazy danych Redis (pamięci podręcznej) oraz usunięty z nagłówka odpowiedzi.
\begin{lstlisting}[label=list:logout,caption=Wylogowanie,basicstyle=\tiny\ttfamily]
    func (c *AuthController) Logout() http.HandlerFunc {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            tokenString := r.Header.Get("Authorization")
            if len(tokenString) == 0 {
                utils.Error(w, r, http.StatusUnauthorized, errors.New("Missing Authorization Header"))
                return
            }
            tokenString = strings.Replace(tokenString, "Bearer ", "", 1)
            claims := &Claims{}
            tkn, err := jwt.ParseWithClaims(tokenString, claims, func(token *jwt.Token) (interface{}, error) {
                return []byte(c.jwtKey), nil
            })
            if err != nil {
                if err == jwt.ErrSignatureInvalid {
                    utils.Error(w, r, http.StatusUnauthorized, err)
                    return
                }
                utils.Error(w, r, http.StatusBadRequest, err)
                return
            }
            if !tkn.Valid {
                utils.Error(w, r, http.StatusUnauthorized, err)
                return
            }
            _, err = c.rClient.Get(tokenString[37:]).Result() // find in Redis db
            if err != redis.Nil {
                utils.Error(w, r, http.StatusUnauthorized, errors.New("Invalid token"))
                return
            }
            params := mux.Vars(r)
            uid, ok := params["id"]
            if !ok {
                utils.Error(w, r, http.StatusBadRequest, utils.ErrWrongRequest)
                return
            }
            if uid != claims.UID {
                utils.Error(w, r, http.StatusBadRequest, utils.ErrWrongRequest)
                return
            }
            c.rClient.Set(tokenString[37:], tokenString, 168*time.Hour) // save to Redis db
            utils.Respond(w, r, http.StatusOK, nil)
        })
    }
\end{lstlisting}

\subsubsection{Stacja}
Głównym przedmiotem w aplikacji jest stacja ładująca pojazdy elektryczne. Aplikacja została stworzona, aby uzyskać informacje o nich. Stacje można tworzyć, przeglądać, a także, jeśli użytkownik jest właścicielem, może je modyfikować.

W listingu \ref{list:station_model} jest przedstawiona struktura encji stacji ładowniczej, wraz ze sposobem konwersji do JSON i BSON, która znajdująca się w pliku \texttt{models/user}.
\begin{lstlisting}[label=list:station_model,caption=Model danych stacji ładowniczej,basicstyle=\tiny\ttfamily]
    type Station struct {
        ID          string    `bson:"_id,omitempty" json:"_id,omitempty"`
        StationName string    `bson:"station_name,omitempty" json:"station_name,omitempty"`
        OwnerID     string    `bson:"owner_id,omitempty" json:"owner_id,omitempty"`
        Rating      float32   `bson:"rating,truncate" json:"rating,truncate"`
        Description string    `bson:"description,omitempty" json:"description,omitempty"`
        Comments    []Comment `bson:"comments,omitempty" json:"comments,omitempty"`
        Latitude    float64   `bson:"latitude" json:"latitude"`
        Longitude   float64   `bson:"longitude" json:"longitude"`
        Model
    }
\end{lstlisting}

\paragraph{Dodawanie}
Żeby dodać nową stację do systemu, należy wysłać zapytanie \texttt{POST} do części serwerów na endpoint \texttt{api/v1/stations}. Zapytanie musi posiadać działający token JWT w nagłówku. Ciało zapytania musi posiadać następujące pola: \texttt{description}, \texttt{station\_name}, \texttt{owner\_id}, \texttt{longitude}, \texttt{latitude}.
Przykład ciała zapytania:
\begin{lstlisting}[basicstyle=\tiny\ttfamily]
    {
		"description": "testText",
		"station_name": "station name",
		"owner_id": "5fbe4b1a187e72c56a5e4f70",
		"longitude":    15.162,
		"latitude": 12.46
    }
\end{lstlisting}

Router przekieruje, po przechodzeniu przez funkcje medialne, w tym sprawdzenie JWT tokena, dane do kontrolera \texttt{CreateStation()} \ref{list:controller_create_station} (plik \texttt{controllers/api/v1/stationcontoller.go}) który dekoduje wchodzący JSON w obiekt struktury \texttt{station}.
Ta metoda wywołuje serwis \texttt{CreateStation} \ref{list:service_create_station}, znajdujący się w pliku \texttt{services/api/v1/stationservice.go}, w którym sprawdza się, czy istnieje stacja w tej pozycji, tworzy stację w bazie danych (metoda \texttt{Create} \ref{list:repo_create_station} z pliku \texttt{storage/mongostore/stationrepository.go}) oraz, przy udanym wpisie, pobiera się z bazy danych ten dokumenty (listing \ref{list:}) i wysyła się jako ciało odpowiedzi.
Przed tworzeniem wpisu w bazie danych zachodzi walidacja danych oraz uzupełnienie pól niektórych niezbędnych, na przykład czasu tworzenia i ostatniej modyfikacji.
\begin{lstlisting}[label=list:controller_create_station,caption=Kontroler tworzenia stacji ładowniczej,basicstyle=\tiny\ttfamily]
    func (c *StationController) CreateStation() http.HandlerFunc {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            s := &models.Station{}
            err := json.NewDecoder(r.Body).Decode(s)
            if err != nil {
                utils.Error(w, r, http.StatusBadRequest, err)
                return
            }
            s, err = c.service.Station().CreateStation(s)
            if err != nil {
                utils.Error(w, r, http.StatusBadRequest, err)
                return
            }
            utils.Respond(w, r, http.StatusCreated, s)
        })
    }
\end{lstlisting}

\begin{lstlisting}[label=list:service_create_station,caption=Serwis tworzenia stacji ładowniczej,basicstyle=\tiny\ttfamily]
    func (s *StationService) CreateStation(st *models.Station) (*models.Station, error) {
        if err := st.Validate(); err != nil {
            return st, err
        }
        _, err := s.storage.Station().FindByLocation(st.Latitude, st.Longitude)
        if err != utils.ErrRecordNotFound {
            if err != nil {
                return nil, err
            }
            return st, utils.ErrRecordAlreadyExists
        }
        if err := st.BeforeCreate(); err != nil {
            return st, err
        }
        id, err := s.storage.Station().Create(st)
        if err != nil {
            return nil, err
        }
        st, err = s.storage.Station().FindByID(id)
        if err != nil {
            return nil, err
        }
        return st, nil
    }
\end{lstlisting}

\begin{lstlisting}[label=list:repo_create_station,caption=Dodanie wpisu stacji ładowniczej do bazy danych,basicstyle=\tiny\ttfamily]
    func (r *StationRepository) Create(s *models.Station) (string, error) {
        res, err := r.col.InsertOne(context.TODO(), s)
        if err != nil {
            return "", err
        }
        id := res.InsertedID.(primitive.ObjectID).Hex()
        return id, nil
    }
\end{lstlisting}

\begin{lstlisting}[label=list:before_create_station,caption=Walidacja danych stacji ładowniczej,basicstyle=\tiny\ttfamily]
    func (s *Station) Validate() error {
        return validation.ValidateStruct(
            s,
            validation.Field(&s.StationName, validation.Required, validation.Length(2, 100)),
            validation.Field(&s.Description, validation.Required, validation.Length(5, 512)),
            validation.Field(&s.OwnerID, validation.Required, validation.Length(20, 30)),
            validation.Field(&s.Latitude, validation.Required, validation.Max(float64(90))),
            validation.Field(&s.Latitude, validation.Required, validation.Min(float64(-90))),
            validation.Field(&s.Longitude, validation.Required, validation.Max(float64(180))),
            validation.Field(&s.Longitude, validation.Required, validation.Min(float64(-180))),
        )
    }
\end{lstlisting}Walidacja danych stacji ładowniczej

\begin{lstlisting}[label=list:validation_station,caption=Uzupełnienie danych systemowych dotyczących,basicstyle=\tiny\ttfamily]
    func (s *Station) BeforeCreate() error {
        s.Model.BeforeCreate()
        s.Rating = 0
        return nil
    }
\end{lstlisting}

\paragraph{Wczytywanie}
Do otrzymania danych konkretnej stacji należy wysłać zapytanie \texttt{GET} na URL \texttt{api/v1/stations/{id}}. Na podstawie \texttt{id} podanego w adresie będzie znaleziony odpowiedni wpis w bazie danych lub, jeśli takiego nie istnieje, zwrócony pusty komunikat z nagówkiem \texttt{204 Status No Content}.

Po przekierowaniu przez router z URL do metody kontrolera \texttt{FindByID()} \ref{list:controller_read_station} (plik \texttt{controllers/api/v1/stationcontroller.go}), jest wycięty z URL adresu \texttt{id} stacji ładowniczej orza wywołana metoda \texttt{FindByID()} \ref{list:service_read_station} (plik \texttt{services/api/v1/stationservice.go}).
Tesn serwis tylko wywołuje metodę (\texttt{FindByID} \ref{list:repo_read_station}, która znajduje się w \texttt{/storage/mongostore/stationrepository.go}) która już bezpośrednio zwraca się do sterownika bazą danych MongoDB w języku Go.
% 
\begin{lstlisting}[label=list:controller_read_station,caption=Kontroler wczytywania danych stacji ładowniczej,basicstyle=\tiny\ttfamily]
    func (c *StationController) FindByID() http.HandlerFunc {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            params := mux.Vars(r)
            id, ok := params["id"]
            if !ok {
                utils.Error(w, r, http.StatusBadRequest, utils.ErrWrongRequest)
                return
            }
            s, err := c.service.Station().FindByID(id)
            if err != nil {
                utils.Error(w, r, http.StatusNoContent, err)
                return
            }
            utils.Respond(w, r, http.StatusFound, s)
        })
    }
\end{lstlisting}

\begin{lstlisting}[label=list:service_read_station,caption=Serwis wczytywania danych stacji ładowniczej,basicstyle=\tiny\ttfamily]
    func (s *StationService) FindByID(id string) (*models.Station, error) {
        st, err := s.storage.Station().FindByID(id)
        if err != nil {
            return nil, err
        }
        return st, nil
    }
\end{lstlisting}

\begin{lstlisting}[label=list:repo_read_station,caption=Wyszukiwanie dokumentu w bazie danych,basicstyle=\tiny\ttfamily]
    func (r *StationRepository) FindByID(id string) (*models.Station, error) {
        idi, err := primitive.ObjectIDFromHex(id)
        if err != nil {
            return nil, err
        }
        filter := bson.M{"_id": idi}
        res := r.col.FindOne(context.TODO(), filter)
        s := &models.Station{}
        err = res.Decode(s)
        if err != nil {
            return nil, utils.ErrRecordNotFound
        }
        return s, nil
    }
\end{lstlisting}

\paragraph{Wyszukiwanie}
W zależności od parametrów w adresie URL przy wysłaniu zapytania metodą \texttt{GET} na adres \texttt{api/v1/stations/read} będzie zrobione wyszukiwanie według różnych parametrów.
Dostęp mają tylko zalogowani użytkownicy.

Lista parametrów (kolejność nie ma znaczenia):
\begin{itemize}
    \item \texttt{skip} -- pominięcie jakiejś ilości elementów (niezbędny parametr);
    \item \texttt{limit} -- ograniczenie ilości zwracanych elementów (niezbędny parametr);
    \item \texttt{name} -- wyszukiwanie według nazwy.
    \item \texttt{descr} (ang. ~\emph{description}) -- wyszukiwanie według opisu.
    \item \texttt{lat} (ang. ~\emph{latitude}) -- szerokość geograficzna. Wyszukiwania według dokładnych współrzędnych geograficznych. Należy używać razem \texttt{lng}.
    \item \texttt{lng}(ang. ~\emph{longitude}) -- długość geograficzna. Wyszukiwania według dokładnych współrzędnych geograficznych. Należy używać razem \texttt{lat}.
    \item \texttt{dist} (ang. ~\emph{distance}) -- promień wyszukiwania wokół współrzędnych geograficznych ustalonych za pomocą \texttt{lat}, \texttt{lng}. Wyszukiwanie zachodzi nie w promieniu od współrzędnych, lecz w kwadracie (odmierzamy dystans na wschód, na zachód, na północ oraz na południe).Jest opcjonalny przy użyciu \texttt{lat} oraz \texttt{lng}. Nie używa się osobno.
\end{itemize}

Przykład użycia: wyszukiwanie dwustu stacji ładowniczych w promieniu 100 kilometrów wokół pewnych współrzędnych geograficznych \texttt{http://127.0.0.1:8081/api/v1/stations/read?lat=57\&lng=15\&skip=0\&limit=200\&dist=100}.

Router przekieruje do metody kontrolera \texttt{Read()} \ref{list:controller_read_station} (plik \texttt{controllers/api/v1/stationcontroller.go}) dalej w zależności od wprowadzonych parametrów będzie wywołana ta czy inna metoda serwisu.
Przy wprowadzaniu dwóch parametrów, na przykład \texttt{name} razem z \texttt{desc} będzie zrobione wyszukiwanie tylko według jednego parametru, w tym przypadku \texttt{name}. Jeśli wyszukiwanie zachodzi według nazwy lub opisu, zostały wykorzystane wyrażenia regularne, co pozwala wyszukiwać wiedząc tylko część nazwy lub opisu.
Dla selekcji wyników w kilku etapów wykorzystana agregacja (metoda \texttt{Aggregare}), która po kolej prowadzi różne przekształcenia danych według sekwencji przenośnika (metoda \texttt{Pipeline}).

Lista przypadków w zależności od parametru (Wszystkie te metody znajdują się w pliku \texttt{services/api/v1/stationservice.go}):
\begin{itemize}
    \item \texttt{name} -- wykonuje się metoda \texttt{FindByName()} \ref{list:service_read_station_FindByName}, która wywołuje się metoda współpracy z bazą danych \texttt{FinDByName()} \ref{list:repo_read_station_FindByName};
    \item \texttt{descr} -- wykonuje się metoda \texttt{FindByDescription()} \ref{list:service_read_station_FindByDescription}, która wywołuje się metoda współpracy z bazą danych \texttt{FindByDescription()} \ref{list:repo_read_station_FindByDescription};
    \item \texttt{dist} razem z \texttt{lat} oraz \texttt{lng} -- wykonuje się metoda \texttt{FindInRadius()} \ref{list:service_read_station_FindInRadius}, która wywołuje się metoda współpracy z bazą danych \texttt{FindInRadius()} \ref{list:repo_read_station_FindInRadius};
    \item \texttt{lat} oraz \texttt{lng} -- wykonuje się metoda \texttt{FindByLocation()} \ref{list:service_read_station_FindByLocation}, która wywołuje się metoda współpracy z bazą danych \texttt{FindByLocation()} \ref{list:repo_read_station_FindByLocation};
    \item \texttt{skip} razem z \texttt{limit} -- bedzie pobrana lista kolejnych dokumentów z bazy danych, która będzie ograniczona przez te parametry (metoda \texttt{Read()} \ref{list:service_read_station_Read}), która wywołuje się metoda współpracy z bazą danych \texttt{Read()} \ref{list:repo_read_station_Read}.
\end{itemize}

\begin{lstlisting}[label=list:controller_read_station,caption=Kontroler wyszukiwania stacji ładowniczych,basicstyle=\tiny\ttfamily]
    func (c *StationController) Read() http.HandlerFunc {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            params := r.URL.Query()
            skipINT, err := strconv.Atoi(params.Get("skip"))
            if err != nil {
                utils.Error(w, r, http.StatusNoContent, err)
                return
            }
            limitINT, err := strconv.Atoi(params.Get("limit"))
            if err != nil {
                utils.Error(w, r, http.StatusNoContent, err)
                return
            }
            name := params.Get("name")
            if name != "" {
                stations, err := c.service.Station().FindByName(name)
                if err != nil {
                    utils.Error(w, r, http.StatusNoContent, err)
                    return
                }
                utils.Respond(w, r, http.StatusOK, stations)
                return
            }
            descr := params.Get("descr")
            if name != "" {
                stations, err := c.service.Station().FindByDescription(descr)
                if err != nil {
                    utils.Error(w, r, http.StatusNoContent, err)
                    return
                }
                utils.Respond(w, r, http.StatusOK, stations)
                return
            }
            latitude, err := strconv.ParseFloat(params.Get("lat"), 64)
            if err == nil {
                longitude, err := strconv.ParseFloat(params.Get("lng"), 64)
                if err == nil {
                    // if we want to find station in radius around the coordinates
                    distance, err := strconv.Atoi(params.Get("dist"))
                    if err == nil && distance != 0 {
                        stations, err := c.service.Station().FindInRadius(latitude, longitude, distance, skipINT, limitINT)
                        if err != nil {
                            utils.Error(w, r, http.StatusNoContent, err)
                            return
                        }
                        utils.Respond(w, r, http.StatusOK, stations)
                        return
                    }
                    // if we want get station in coordinates
                    station, err := c.service.Station().FindByLocation(latitude, longitude)
                    if err != nil {
                        utils.Error(w, r, http.StatusNoContent, err)
                        return
                    }
                    utils.Respond(w, r, http.StatusOK, station)
                    return
                }
            }
            stations, err := c.service.Station().Read(skipINT, limitINT)
            if err != nil {
                utils.Error(w, r, http.StatusNoContent, err)
                return
            }
            utils.Respond(w, r, http.StatusOK, stations)
        })
    }
\end{lstlisting}
\begin{lstlisting}[label=list:service_read_station_FindByName,caption=Serwis wyszukiwania stacji ładowniczych według nazwy,basicstyle=\tiny\ttfamily]
    func (s *StationService) FindByName(name string) ([]models.Station, error) {
        st, err := s.storage.Station().FindByName(name)
        if err != nil {
            return nil, err
        }
        return st, nil
    }
\end{lstlisting}
\begin{lstlisting}[label=list:repo_read_station_FindByName,caption=Wyszukiwanie stacji ładowniczych w bazie danych według nazwy,basicstyle=\tiny\ttfamily]
    func (r *StationRepository) FindByName(name string) ([]models.Station, error) {
        filter := bson.D{{"station_name", primitive.Regex{Pattern: name, Options: "i"}}}
        cursor, err := r.col.Aggregate(
            context.TODO(),
            mongo.Pipeline{
                bson.D{{"$match",
                    filter}},
            })
        if err != nil {
            return nil, err
        }
        s := []models.Station{}
        err = cursor.All(context.TODO(), &s)
        if err != nil {
            return nil, err
        }
        return s, nil
    }
\end{lstlisting}
\begin{lstlisting}[label=list:service_read_station_FindByDescription,caption=Serwis wyszukiwania stacji ładowniczych według opisu,basicstyle=\tiny\ttfamily]
    func (s *StationService) FindByDescription(text string) ([]models.Station, error) {
        st, err := s.storage.Station().FindByName(text)
        if err != nil {
            return nil, err
        }
        return st, nil
    }
\end{lstlisting}
\begin{lstlisting}[label=list:repo_read_station_FindByDescription,caption=Wyszukiwanie stacji ładowniczych w bazie danych według opisu,basicstyle=\tiny\ttfamily]
    func (r *StationRepository) FindByDescription(text string) ([]models.Station, error) {
        filter := bson.D{{"description", primitive.Regex{Pattern: text, Options: "i"}}}
        log.Println(filter)
        cursor, err := r.col.Aggregate(
            context.TODO(),
            mongo.Pipeline{
                bson.D{{"$match",
                    filter}},
            })
        if err != nil {
            return nil, err
        }
        s := []models.Station{}
        err = cursor.All(context.TODO(), &s)
        if err != nil {
            return nil, err
        }
        return s, nil
    }
\end{lstlisting}
\begin{lstlisting}[label=list:service_read_station_FindInRadius,caption=Serwis wyszukiwania stacji ładowniczych w pobliżu podanych współrzędnych na mapie Ziemi,basicstyle=\tiny\ttfamily]
    func (s *StationService) FindInRadius(latitude float64, longitude float64, radius int, skip int, limit int) ([]models.Station, error) {
        st, err := s.storage.Station().FindInRadius(getLatitude(latitude), getLongitude(longitude), getRadius(radius), skip, limit)
        if err != nil {
            return nil, err
        }
        return st, nil
    }
\end{lstlisting}
\begin{lstlisting}[label=list:repo_read_station_FindInRadius,caption=Wyszukiwanie stacji ładowniczych w bazie danych w pobliżu podanych współrzędnych na mapie Ziemi,basicstyle=\tiny\ttfamily]
    func (r *StationRepository) FindInRadius(latitude float64, longitude float64, radius float64, skip int, limit int) ([]models.Station, error) {
        matchInRadius := bson.D{{"$match", bson.M{
            "$and": []interface{}{
                bson.M{"latitude": bson.M{
                    "$gte": latitude - radius}},
                bson.M{"latitude": bson.M{
                    "$lte": latitude + radius}},
                bson.M{"longitude": bson.M{
                    "$gte": longitude - radius}},
                bson.M{"longitude": bson.M{
                    "$lte": longitude + radius}},
            }},
        }}
        cursor, err := r.col.Aggregate(
            context.TODO(),
            mongo.Pipeline{
                matchInRadius,
                bson.D{{"$skip", skip}},
                bson.D{{"$limit", limit}},
            })
        if err != nil {
            return nil, err
        }
        stations := []models.Station{}
        err = cursor.All(context.TODO(), &stations)
        if err != nil {
            return nil, err
        }
        return stations, nil
    }
\end{lstlisting}
\begin{lstlisting}[label=list:service_read_station_FindByLocation,caption=Serwis wyszukiwania stacji ładowniczych według współrzędnych na mapie Ziemi,basicstyle=\tiny\ttfamily]
    func (s *StationService) FindByLocation(latitude float64, longitude float64) (*models.Station, error) {
        st, err := s.storage.Station().FindByLocation(getLatitude(latitude), getLongitude(longitude))
        if err != nil {
            return nil, err
        }
        return st, nil
    }
\end{lstlisting}
\begin{lstlisting}[label=list:repo_read_station_FindByLocation,caption=Wyszukiwanie stacji ładowniczych w bazie danych współrzędnych pozycji na mapie Ziemi,basicstyle=\tiny\ttfamily]
    func (r *StationRepository) FindByLocation(latitude float64, longitude float64) (*models.Station, error) {
        filter := bson.M{"latitude": latitude, "longitude": longitude}
        res := r.col.FindOne(context.TODO(), filter)
        s := &models.Station{}
        err := res.Decode(s)
        if err != nil {
            return nil, utils.ErrRecordNotFound
        }
        return s, nil
    }
\end{lstlisting}
\begin{lstlisting}[label=list:service_read_station_Read,caption=Serwis wczytania listy kolejnych stacji ładowniczych,basicstyle=\tiny\ttfamily]
    func (s *StationService) Read(skip int, limit int) ([]models.Station, error) {
        st, err := s.storage.Station().Read(skip, limit)
        if err != nil {
            return nil, err
        }
        return st, nil
    }
\end{lstlisting}
\begin{lstlisting}[label=list:repo_read_station_Read,caption=Wczytanie listy kolejnych stacji ładowniczych z bazy danych,basicstyle=\tiny\ttfamily]
    func (r *StationRepository) Read(skip int, limit int) ([]models.Station, error) {
        cursor, err := r.col.Aggregate(
            context.TODO(),
            mongo.Pipeline{
                bson.D{{"$skip", skip}},
                bson.D{{"$limit", limit}},
            })
        if err != nil {
            return nil, err
        }
        stations := []models.Station{}
        err = cursor.All(context.TODO(), &stations)
        if err != nil {
            return nil, err
        }
        return stations, nil
    }
\end{lstlisting}

Dla wyszukiwania listy stacji ładowniczych w pobliżu podanych współrzędnych na mapie Ziemi należy wykorzystać wzór obliczający długość łuku (${L = \alpha R}$, gdzie L - długość łuku w kilometrach, ${\alpha}$ - kąt, R - radius Ziemi (6378 km.)) do przekształcenia kilometrów do stopień kąta (${\alpha = L/R*180/\pi}$). To przekształcenie zachodzi w metodzie \texttt{getRadius()} \ref{list:get_radius.}.
\begin{lstlisting}[label=list:get_radius,caption=Obliczenie dystansu przeszukiwania,basicstyle=\tiny\ttfamily]
    func getRadius(rad int) float64 {
        if rad > 40074 {
            rad = 40074
        }
        radius := float64(float64(float64(rad)/float64(6378)) * float64(180) / math.Pi)
        return radius
    }
\end{lstlisting}

\paragraph{Edycja}

Do edycji stacji ładowniczej został zaimplementowany endpoint \texttt{/api/v1/stations/{id}?ownid=""}.
Metoda zapytania \texttt{PUT}.
W adresie URL musi być podany id użytkownika. Oraz jako parametr id użytkownika, który probuje edytować. Edytować może tylko właściciel stacji oraz dla zapobiegania jednoczesnej edycji musi zgadzać się pole \texttt{update\_at}, które przechowuje datę ostatniej modyfikacji.
Dostęp mają tylko zalogowani użytkownicy.
Jako ciało zapytania należy wysyłać obiekt w formacie JSON. Do edycji dozwolone następujące pola: \texttt{description}, \texttt{station\_name}.
Przykład ciała zapytania:
\begin{lstlisting}[,basicstyle=\tiny\ttfamily]
    {
		"description": "testText",
		"station_name": "station name"
    }
\end{lstlisting}

Router przekieruje z adresu URL do metody kontrolera \texttt{UpdateByID()} \ref{list:controller_station_UpdateByID} z pliku \texttt{controllers/api/v1}. W tej metodzie zostaje pobrany \texttt(id) stacji oraz \texttt(ownid), dla sprawdzenia właściciela.
Dalej jest wywoływania metoda serwisu \texttt{UpdateByID()} \ref{list:service_station_UpdateByID}, w której wywołują się metody współpracy z bazą danych \texttt{UpdateByID()} \ref{list:repo_station_UpdateByID} oraz \texttt{FidByID()} \ref{list:repo_read_station} do zmiany dokumentu we wpisie oraz pobraniu wynikowego dokumentu.
\begin{lstlisting}[label=list:controller_station_UpdateByID,caption=Kontroler edycji stacji ładowniczej,basicstyle=\tiny\ttfamily]
    func (c *StationController) UpdateByID() http.HandlerFunc {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            params := mux.Vars(r)
            query := r.URL.Query()
            id, ok := params["id"]
            if !ok {
                utils.Error(w, r, http.StatusNoContent, utils.ErrWrongRequest)
                return
            }
            ownid := query.Get("ownid")
            s := &models.Station{}
            err := json.NewDecoder(r.Body).Decode(s)
            if err != nil {
                utils.Error(w, r, http.StatusBadRequest, err)
                return
            }
            s, err = c.service.Station().UpdateByID(id, s, ownid)
            if err != nil {
                utils.Error(w, r, http.StatusNotFound, err)
                return
            }
            utils.Respond(w, r, http.StatusOK, s)
        })
    }
\end{lstlisting}
\begin{lstlisting}[label=list:service_station_UpdateByID,caption=Serwis edycji stacji ładowniczej,basicstyle=\tiny\ttfamily]
    func (s *StationService) UpdateByID(id string, st *models.Station, ownerID string) (*models.Station, error) {
        err := s.storage.Station().UpdateByID(id, st, ownerID)
        if err != nil {
            return nil, err
        }
        st, err = s.storage.Station().FindByID(id)
        if err != nil {
            return nil, err
        }
        return st, nil
    }
\end{lstlisting}
\begin{lstlisting}[label=list:repo_station_UpdateByID,caption=Edycja stacji ładowniczej w bazie danych,basicstyle=\tiny\ttfamily]
    func (r *StationRepository) UpdateByID(id string, s *models.Station, ownerID string) error {
        idi, err := primitive.ObjectIDFromHex(id)
        if err != nil {
            return err
        }
        filter := bson.M{
            "_id":             idi,
            "model.update_at": s.UpdateAt,
            "owner_id":        ownerID,
        }
        update := bson.M{
            "model.update_at": models.GetTimeNow(),
        }
        if s.Description != "" {
            update["description"] = s.Description
        }
        if s.StationName != "" {
            update["station_name"] = s.StationName
        }
        _, err = r.col.UpdateOne(context.TODO(), filter, bson.M{
            "$set": update})
        if err != nil {
            return err
        }
        return nil
    }
\end{lstlisting}

\paragraph{Usunięcie}
\subsubsection{Komentarz}
Stacja ładownicza przechowuje listę komentarzy. Komentarz zawiera tekst napisany przez użytkownika, który go stworzył, oraz oceny, na podstawie której jest oceniana cała stacja.
Struktura komentarza w języku Go, sposób przekazania do obiektu JSON oraz BSON znajduje się w listingu \ref{list:comment_struct}.
\begin{lstlisting}[label=list:comment_struct,caption=Struktura komentarza,basicstyle=\tiny\ttfamily]
    type Comment struct {
        ID       string  `bson:"_id,omitempty" json:"_id,omitempty"`
        UserID   string  `bson:"user_id,omitempty" json:"user_id,omitempty"`
        UserName string  `bson:"user_name,omitempty" json:"user_name,omitempty"`
        Text     string  `bson:"text,omitempty" json:"text,omitempty"`
        Rating   float32 `bson:"rating,omitempty,truncate" json:"rating,omitempty,truncate"`
        Model
    }
\end{lstlisting}

\paragraph{Dodawanie}
W celu umożliwiana tworzenia komentarza został zaimplementowany endpotint \texttt{/api/v1/stations/{sid}/comments}.
Zapytanie wysyła się metodą \texttt{POST}, ciało zawiera następujące pola: \texttt{user\_id}, \texttt{rating}, \texttt{text}, \texttt{user\_name}.
Dla tworzenia komentarza do stacji ładowniczej zapytanie musi posiadać działający token JWT oraz w adresie URL musi być podany \texttt{id} (\texttt{sid} -to \texttt{id} stacji) tej stacji.
Przykład ciała zapytania:
\begin{lstlisting}[basicstyle=\tiny\ttfamily]
    {
		"user_id":   "5fb828babe10c57ba70d49cd",
		"rating":  3,
		"text":     "some text",
		"user_name": "test username"
    }
\end{lstlisting}

Router przekieruje zapytanie, po przechodzeniu autentykacji, do metody kontrolera \texttt{CreateComment()} \ref{list:controller_comment_create} (plik \texttt{controllers/api/v1/commentcontroller.go}), w której zachodzi otrzymanie niezbędnych danych z adresu URL oraz zaczyna się część biznesowa w metodzie \texttt{CreateComment()} \ref{list:service_comment_create} (plik \texttt{services/api/v1/commentservice.go}).
W tym serwisie zachodzi walidacja (\texttt{Validation()} \ref{list:validate_comment}), dodawanie niektórych pól (na przykład czas tworzenia i ostatniej modyfikacji), dodanie nowego komentarza na początek listy komentarzy stacji ładowniczej (jest to edycja dokumenta stacji ładowniczej w bazie danych o podanym numerze \texttt{id} (\texttt{Create} \ref{list:repo_comment_create})) oraz obliczenie oceny wynikowej stacji ładowniczej z uwzględnieniem nowego komentarza za pomocą metody \texttt{UpdateRaitingByID} z pliku (storage/mongostore/stationrepository.go) \ref{list:update_rating}.
Do aktualizaji oceny została wykorzystana agregacja postępów: za pomocą parametru \texttt{\$reduce} została obliczona suma ocen wszytkich komentzry, podzielona (\texttt{\$divide}) przez liczbę komentarzy (\texttt{\$cond}), i zachowana w pole \texttt{rating} za pomocą parametra \texttt{\$set}\ref{list:update_rating}.
\begin{lstlisting}[label=list:controller_comment_create,caption=Struktura komentarza,basicstyle=\tiny\ttfamily]
    func (c *CommentController) CreateComment() http.HandlerFunc {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            params := mux.Vars(r)
            sid, ok := params["sid"]
            if !ok {
                utils.Error(w, r, http.StatusBadRequest, utils.ErrWrongRequest)
                return
            }
            comm := &models.Comment{}
            err := json.NewDecoder(r.Body).Decode(comm)
            if err != nil {
                utils.Error(w, r, http.StatusBadRequest, err)
                return
            }
            comm, err = c.service.Comment().CreateComment(sid, comm)
            if err != nil {
                utils.Error(w, r, http.StatusBadRequest, err)
                return
            }
            utils.Respond(w, r, http.StatusCreated, comm)
        })
    }
\end{lstlisting}
\begin{lstlisting}label=list:service_comment_create,caption=Kontroler tworzenia komentarza,[basicstyle=\tiny\ttfamily]
    func (s *CommentService) CreateComment(sid string, c *models.Comment) (*models.Comment, error) {
        if err := c.Validate(); err != nil {
            return c, err
        }
        if err := c.BeforeCreate(); err != nil {
            return c, err
        }
        id, err := s.storage.Comment().Create(sid, c)
        if err != nil {
            return nil, err
        }
        go func() {
            err := s.storage.Station().UpdateRaitingByID(sid)
            if err != nil {
                log.Println(err.Error())
            }
        }()
        c, err = s.storage.Comment().FindByID(sid, id)
        if err != nil {
            return nil, err
        }
        return c, nil
    }
\end{lstlisting}
\begin{lstlisting}[label=list:repo_comment_create,caption=Serwis tworzenia komentarza,basicstyle=\tiny\ttfamily]
    func (r *CommentRepository) Create(sid string, c *models.Comment) (string, error) {
        sidi, err := primitive.ObjectIDFromHex(sid)
        if err != nil {
            return "", err
        }
        filter := bson.M{
            "_id": sidi,
        }
        update1 := bson.M{
            "comments": bson.M{
                "$each":     bson.A{c},
                "$position": 0,
            }}
        update2 := bson.M{"model.update_at": models.GetTimeNow()}
        _, err = r.stationRepository.col.UpdateOne(
            context.TODO(),
            filter,
            bson.M{
                "$push": update1,
                "$set":  update2,
            })
        if err != nil {
            return "", err
        }
    
        return c.ID, nil
    }
\end{lstlisting}
\begin{lstlisting}[label=list:update_rating,caption=Aktualizacja oceny stacji,basicstyle=\tiny\ttfamily]
    func (r *StationRepository) UpdateRaitingByID(id string) error {
        idi, err := primitive.ObjectIDFromHex(id)
        filter := bson.M{"_id": idi}
        avg := bson.D{{
            "$set", bson.M{
                "rating": bson.M{
                    "$divide": []interface{}{
                        bson.M{
                            "$reduce": bson.M{
                                "input":        "$comments",
                                "initialValue": 0,
                                "in":           bson.M{"$add": []interface{}{"$$value", "$$this.rating"}},
                            },
                        },
                        bson.M{
                            "$cond": []interface{}{
                                bson.M{"$ne": []interface{}{bson.M{"$size": "$comments"}, 0}},
                                bson.M{"$size": "$comments"},
                                1,
                            },
                        },
                    },
                },
            },
        }}
        _, err = r.col.UpdateOne(
            context.TODO(),
            filter,
            mongo.Pipeline{avg})
        return err
    }
\end{lstlisting}
\begin{lstlisting}[label=list:validate_comment,caption=Tworzenie komentarza w bazie danych,basicstyle=\tiny\ttfamily]
    func (c *Comment) Validate() error {
        return validation.ValidateStruct(
            c,
            validation.Field(&c.UserName, validation.Required, validation.Length(2, 100)),
            validation.Field(&c.UserID, validation.Required, validation.Length(20, 30)),
            validation.Field(&c.Text, validation.Required, validation.Length(8, 256)),
        )
    }
\end{lstlisting}


\paragraph{Wczytywanie}
\paragraph{Edycja}
\paragraph{Usunięcie}
%
\section{Implementacja Interfejsu użytkownika}
Interfejs użytkownika jest aplikacją mobilną dla telefonów z systemem operacyjnym Android.
\subsection{Struktura AndroidUI}
\subsubsection{Narzędzia, technologie, biblioteki}
Do stworzenia serwerowej części aplikacji użyto następujących technologii:
\begin{itemize}
    \item Android Studio - środowisko programistyczne;
    \item Java SDK 8 - Narzędzia programistyczne języka Java wersji 8;
    \item Grable - system zarządzania zależnościami oraz budowaniem projektu;
    \item OkHttp3 - HTTP klient;
    \item Retrofit - Służąca do komunikacji przez interfejsy API opakowanie dla OkHttp3;
    \item RxJava2 - Biblioteka umożliwiająca programowanie reaktywne w języku Java;
    \item gms:play-services-maps - Narzędzia programistyczne do pracy z mapą Google. Jest częścią Google Maps Android API;
    \item gms:play-services-location - Narzędzia programistyczne do pracy z położeniem urządzenia użytkownika. Jest częścią Google Maps Android API;
    \item android-maps-utils - Narzędzia programistyczne do pracy z elementami dodatkowymi mapy (na przykład markery). Jest częścią Google Maps Android API;
    \item gson - Służy do konwersji obiektów do Formaty JSON;
    \item yaml.v2 - implementuje obsługę YAML (ang. \textit{Yet Another Markup Language});
\end{itemize}

\subsubsection{Struktura plików AndroidUI}
Na rysunku \ref{fig:frontend_file_structure} została przedstawiona struktura plików aplikacji mobilnej. Ta struktura ma dość głębokie drzewo, więc dalej będzie wykorzystany jako katalog korzeniowy \texttt{app/src/main}.

\begin{figure}[ht]
\centering
\includegraphics[width=0.4\linewidth]{rys03/frontend_file_struct.png}
\caption{Struktura plików aplikacji mobilnej}
\label{fig:frontend_file_structure}
\end{figure}

Zawartość znaczących katalogów i plików:
\begin{itemize}
    \item katalog \texttt{main/java/com/example/testapp/activities} zawiera klasy \texttt{activity}, są oknami aplikacji, na których umieszczone wszystkie komponenty interfejsu użytkownika.
    \item katalog \texttt{main/java/com/example/testapp/api} zawiera modeli danych (\texttt{katalog models}, sposób komunikacji z częścią serwerową (katalog \texttt{services}) oraz endpointy do połączenia (katalog \texttt{api} \ref{fig:frontend_file_structure_1}a).
    \item katalog \texttt{main/java/com/example/testapp/fragments} zawiera klasy fragmentów (fig. \ref{fig:frontend_file_structure_1}b), które umieszczają się w kontenerze na \texttt{activity} i zawierają elementy interfejsu użytkownika (przyciski, pola tekstowe i inne).
    \item w katalogu \texttt{res} znajdują się zasoby aplikacji, na przykład: plik konfiguracyjny (\texttt{res/raw/config.properties}), opisy komponentów oraz ich dyslokacja na fragmentach i oknach aplikacji (\texttt{res/layout/}) \ref{fig:frontend_file_structure_1}c.
    \item plik \texttt{main/androidManifest.xml} (listing \ref{list:androidManifest}) zawiera informację niezbędną do budowy aplikacji: definiowanie \texttt{activity}, uprawnień, klasy podstawowej.
    \item plik \texttt{main/java/com/example/testapp/App.java} jest klasą podstawową, który jest niezbędny do podtrzymywania globalnego stanu aplikacji (\texttt{ApplicatioContext}).
\end{itemize}
\begin{figure}[ht]
	\centering
    \begin{tabular}{@{}rl@{\hspace{3mm}}rl@{\hspace{3mm}}rl@{}}
        a) & \vtop{\vskip-2ex\hbox{\includegraphics[width=0.253\linewidth]{rys03/frontend_file_struct_api.png}}} &
        b) & \vtop{\vskip-2ex\hbox{\includegraphics[width=0.27\linewidth]{rys03/frontend_file_struct_fragements.png}}} &
        c) & \vtop{\vskip-2ex\hbox{\includegraphics[width=0.30\linewidth]{rys03/frontend_file_struct_layout.png}}}
    \end{tabular}
    \caption{Struktura plików: a) API do połączenia z serwerem, b) klasy fragmentów, c) opis fragmentów.}
    \label{fig:frontend_file_structure_1}
\end{figure}
\begin{lstlisting}[label=list:androidManifest,caption=androidManifest.xml,basicstyle=\tiny\ttfamily]
    <?xml version="1.0" encoding="utf-8"?>
    <manifest xmlns:android="http://schemas.android.com/apk/res/android"
        package="com.example.testapp">
    
        <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" />
        <uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" />
        <uses-permission android:name="android.permission.INTERNET" />
        <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
        <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" />
        <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/>
    
        <application
            android:name=".App"
            android:allowBackup="true"
            android:icon="@mipmap/ic_launcher"
            android:label="@string/app_name"
            android:roundIcon="@mipmap/ic_launcher_round"
            android:supportsRtl="true"
            android:theme="@style/AppTheme"
            android:usesCleartextTraffic="true">
            <meta-data
                android:name="com.google.android.geo.API_KEY"
                android:value="@string/google_maps_key" />
    
            <activity android:name=".activities.MainActivity">
                <intent-filter>
                    <action android:name="android.intent.action.MAIN" />
    
                    <category android:name="android.intent.category.LAUNCHER" />
                </intent-filter>
            </activity>
        </application>
    
    </manifest>
\end{lstlisting}

\paragraph{Modeli danych:} \texttt{User} \ref{list:user_class}, \texttt{Station} \ref{list:station_class}, \texttt{Comment} \ref{list:comment_class}. W listingach komentarz \texttt{// GETTERS and SETTERS} pokazuje, że w kodzie programu tym miejscu znajdują się proste metody do zapisu i wczytania pól klasy.
Adnotacja \texttt{@SerializedName} ustala nazwę do dekodowania do formatu JSON i naodwrót.

\begin{lstlisting}[label=list:user_class,caption=Plik \texttt{main/java/com/example/testapp/api/api/UserApi.java},basicstyle=\tiny\ttfamily]
    public class User {
        @SerializedName("_id")
        private String id;
        @SerializedName("user_name")
        private String userName;
        @SerializedName("email")
        private String email;
        @SerializedName("password")
        private String password;
        @SerializedName("update_at")
        private String updateAt;
    
        public User() {
        }
    
        public User(String id, String userName, String email, String password, String updateAt) {
            this.id = id;
            this.userName = userName;
            this.email = email;
            this.password = password;
            this.updateAt = updateAt;
        }
        // GETTERS and SETTERS
    }
\end{lstlisting}

\begin{lstlisting}[label=list:station_class,caption=Plik \texttt{main/java/com/example/testapp/api/api/StationApi.java},basicstyle=\tiny\ttfamily]
    public class Station {
        @SerializedName("_id")
        private String id;
        @SerializedName("owner_id")
        private String ownerID;
        @SerializedName("description")
        private String description;
        @SerializedName("station_name")
        private String stationName;
        @SerializedName("latitude")
        private double latitude;
        @SerializedName("longitude")
        private double longitude;
        @SerializedName("update_at")
        private String updateAt;
        @SerializedName("rating")
        private float rating;
        @SerializedName("comments")
        private ArrayList<Comment> comments;
    
        public Station() {
        }
    
        public Station(String id, String ownerID, String description, String stationName, double latitude, double longitude, String updateAt, float rating, ArrayList<Comment> comments) {
            this.id = id;
            this.ownerID = ownerID;
            this.description = description;
            this.stationName = stationName;
            this.latitude = latitude;
            this.longitude = longitude;
            this.updateAt = updateAt;
            this.rating = rating;
            this.comments = comments;
        }
        // GETTERS and SETTERS
    }
\end{lstlisting}

\begin{lstlisting}[label=list:comment_class,caption=Plik \texttt{main/java/com/example/testapp/api/api/CommentApi.java},basicstyle=\tiny\ttfamily]
    public class Comment {
        @SerializedName("_id")
        private String id;
        @SerializedName("user_id")
        private String userID;
        @SerializedName("user_name")
        private String userName;
        @SerializedName("text")
        private String text;
        @SerializedName("rating")
        private float rating;
        @SerializedName("create_at")
        private String createAt;
        @SerializedName("update_at")
        private String updateAt;
    
        public Comment() {
        }
    
        public Comment(String id, String userID, String userName, String text, float raiting, String createAt, String updateAt) {
            this.id = id;
            this.userID = userID;
            this.userName = userName;
            this.text = text;
            this.rating = raiting;
            this.createAt = createAt;
            this.updateAt = updateAt;
        }
        // GETTERS and SETTERS
    }
\end{lstlisting}

\paragraph{API:} \texttt{UserApi} \ref{list:android_api_user}, \texttt{StationApi} \ref{list:android_api_station}, \texttt{CommentApi} \ref{list:android_api_comment} są interfejsami do komunikacji przez interfejsy programistyczne z częścią serwerową.
Adnotacje \texttt{POST}, \texttt{PU}, \texttt{GET}, \texttt{DELETE} wskazują na to, którą metodą należy wysłać zapytania do części serwerowej.
Adnotacja \texttt{Body} umieszcza dane do ciała zapytania. Adnotacje \texttt{Path} umieszcza dane jako część adresu URL. Adnotacje \texttt{Query} umieszcza dane jako odpowiednie parametry w adresie URL.

\begin{lstlisting}[label=list:android_api_user,caption=Plik \texttt{main/java/com/example/testapp/api/api/UserApi.java},basicstyle=\tiny\ttfamily]
    public interface UserApi {
        @POST("users")
        public Single<Response<User>> createUser(@Body User body);
    
        @POST("login")
        public Single<Response<User>> login(@Body User body);
    
        @GET("logout/{id}")
        public Single<ResponseBody> logout(@Path("id") String id);
    }
\end{lstlisting}

\begin{lstlisting}[label=list:android_api_station,caption=Plik \texttt{main/java/com/example/testapp/api/api/StationApi.java},basicstyle=\tiny\ttfamily]
    public interface StationApi {

        @POST("stations")
        public Single<Response<Station>> createStation(@Body Station station);
    
        @GET("stations/read")
        public Single<Response<List<Station>>> readStationsByLatAndLngAndDist(@Query("skip") int skip, @Query("limit") int limit, @Query("lat") double lat, @Query("lng") double lng, @Query("dist") int dist);
    
        @GET("stations/read")
        public Single<Response<Station>> readStationsByLatAndLng(@Query("skip") int skip, @Query("limit") int limit, @Query("lat") double lat, @Query("lng") double lng);
    
        @GET("stations/read")
        public Single<Response<List<Station>>> readStationsByDescription(@Query("skip") int skip, @Query("limit") int limit, @Query("descr") String descr);
    
        @GET("stations/read")
        public Single<Response<List<Station>>> readStationsByName(@Query("skip") int skip, @Query("limit") int limit, @Query("name") String name);
    
        @GET("stations/read")
        public Single<Response<List<Station>>> readStations(@Query("skip") int skip, @Query("limit") int limit);
    
        @GET("stations/{id}")
        public Single<Response<Station>> findById(@Path("id") String id);
    
        @PUT("stations/{id}")
        public Single<Response<Station>> updateById(@Path("id") String id, @Query("ownid") String ownid, @Body Station station);
    
        @DELETE("stations/{id}")
        public Single<ResponseBody> deleteById(@Path("id") String id);
    }
\end{lstlisting}

\begin{lstlisting}[label=list:android_api_comment,caption=Plik \texttt{main/java/com/example/testapp/api/api/CommentApi.java},basicstyle=\tiny\ttfamily]
    public interface CommentApi {
        @POST("stations/{sid}/comments")
        public Single<Response<Comment>> createComment(@Path("sid") String sid, @Body Comment comment);
    
        @GET("stations/{sid}/comments/read")
        public Single<Response<List<Comment>>> readComments(@Path("sid") String sid, @Query("skip") int skip, @Query("limit") int limit);
    
        @GET("stations/{sid}/comments/{id}")
        public Single<Response<Comment>> findById(@Path("sid") String sid, @Path("id") String id);
    
        @PUT("stations/{sid}/comments/{id}")
        public Single<Response<Comment>> updateById(@Path("sid") String sid, @Path("id") String id, @Body Comment comment);
    
        @DELETE("stations/{sid}/comments/{id}")
        public Single<ResponseBody> deleteById(@Path("sid") String sid, @Path("id") String id);
    }
\end{lstlisting}

\subsubsection{?? Działanie interfejsu graficznego ??}

\subsection{Funkcje aplikacji mobilnej}
W tej sekcji opisano współdziałanie użytkownika i systemu oraz implementacja tych części.

\subsubsection{Autentykacja / Logowanie i rejestracja}
Dla otwarcia strony logowania lub rejestracji można nacisnąć przycisk w prawym dolnym rogu (koło zębate). Otworzą się ustalenia, jak na rysunku \ref{fig:}, oraz kliknąć \texttt{Log in} (na tej stronie można też wylogować się za pomocą przycisku \texttt{Log out}).
Przy próbie wykorzystania elementów, które potrzebują autentykacji, natomiast użytkownik nie będzie zalogowany do systemu, logowanie \ref{fig:} oraz rejestracja \ref{fig:} będą proponowane automatycznie. Jeśli logowanie zostało proponowane automatycznie, dane poprzedniego ekranu nie będą usuwane, więc po zalogowaniu się można kontynuować pracę.


\subsubsection{Stacja}
\paragraph{Dodawanie}
\paragraph{Wczytywanie}
\paragraph{Edycja}
\subsubsection{Komentarz}
\paragraph{Dodawanie}
\paragraph{Wczytywanie}
